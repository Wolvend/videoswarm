name: Release

on:
  push:
    tags:
      - "v*"
  workflow_dispatch:

permissions:
  contents: write

concurrency:
  group: release-${{ github.ref }}
  cancel-in-progress: false

jobs:
  build:
    name: Build ${{ matrix.os }}
    runs-on: ${{ matrix.os }}
    strategy:
      matrix:
        include:
          - os: ubuntu-latest
            artifact-name: linux
          - os: windows-latest
            artifact-name: windows
          - os: macos-latest
            artifact-name: macos

    steps:
      - name: Checkout
        uses: actions/checkout@v4

      - name: Setup Node
        uses: actions/setup-node@v4
        with:
          node-version: "20"
          cache: "npm"

      - name: Install dependencies
        run: npm ci

      - name: Install Linux build dependencies
        if: matrix.os == 'ubuntu-latest'
        run: |
          sudo apt-get update
          sudo apt-get install -y --no-install-recommends \
            icnsutils graphicsmagick xz-utils rpm

      - name: Build application
        env:
          CSC_IDENTITY_AUTO_DISCOVERY: "false"
        run: npm run electron:dist

      - name: Prepare artifacts
        shell: bash
        run: |
          mkdir -p release-assets
          
          # Only copy the final distributable packages, not unpacked files
          if [ "${{ matrix.os }}" = "ubuntu-latest" ]; then
            # Linux: AppImage and deb files
            find dist -name "*.AppImage" -exec cp {} release-assets/ \; 2>/dev/null || true
            find dist -name "*.deb" -exec cp {} release-assets/ \; 2>/dev/null || true
            find dist -name "*.rpm" -exec cp {} release-assets/ \; 2>/dev/null || true
            find dist -name "*.tar.gz" -exec cp {} release-assets/ \; 2>/dev/null || true
          elif [ "${{ matrix.os }}" = "macos-latest" ]; then
            # macOS: dmg and zip bundles
            find dist -name "*.dmg" -exec cp {} release-assets/ \; 2>/dev/null || true
            find dist -name "*.zip" -exec cp {} release-assets/ \; 2>/dev/null || true
          else
            # Windows: exe installers only
            find dist -name "*.exe" -not -path "*/unpacked/*" -exec cp {} release-assets/ \; 2>/dev/null || true
          fi
          
          # Generate checksums for the files we actually want
          cd release-assets
          if [ -n "$(ls -A . 2>/dev/null)" ]; then
            if command -v sha256sum >/dev/null 2>&1; then
              sha256sum * > SHA256SUMS-${{ matrix.artifact-name }}.txt 2>/dev/null || true
            elif command -v shasum >/dev/null 2>&1; then
              shasum -a 256 * > SHA256SUMS-${{ matrix.artifact-name }}.txt 2>/dev/null || true
            fi
          fi

      - name: List artifacts
        shell: bash
        run: |
          echo "Release assets:"
          ls -la release-assets/ || echo "No release-assets directory found"

      - name: Upload artifacts
        uses: actions/upload-artifact@v4
        with:
          name: videoswarm-${{ matrix.artifact-name }}
          path: release-assets/
          if-no-files-found: warn

  release:
    name: Create Release
    runs-on: ubuntu-latest
    needs: build
    if: startsWith(github.ref, 'refs/tags/v')

    steps:
      - name: Checkout
        uses: actions/checkout@v4

      - name: Download all artifacts
        uses: actions/download-artifact@v4
        with:
          path: all-artifacts

      - name: Prepare release assets
        run: |
          mkdir -p release-files
          # Flatten all artifacts into release-files directory
          find all-artifacts -type f -exec cp {} release-files/ \;
          
          echo "Final release files:"
          ls -la release-files/

      - name: Generate release notes with checksums
        id: release_notes
        run: |
          TAG_NAME="${{ github.ref_name }}"
          
          # Generate checksums for all release files
          cd release-files
          
          # Count different file types for dynamic instructions
          WINDOWS_COUNT=$(ls *.exe 2>/dev/null | wc -l || echo "0")
          APPIMAGE_COUNT=$(ls *.AppImage 2>/dev/null | wc -l || echo "0") 
          DEB_COUNT=$(ls *.deb 2>/dev/null | wc -l || echo "0")
          RPM_COUNT=$(ls *.rpm 2>/dev/null | wc -l || echo "0")
          DMG_COUNT=$(ls *.dmg 2>/dev/null | wc -l || echo "0")
          MACZIP_COUNT=$(ls *.zip 2>/dev/null | wc -l || echo "0")
          
          # Build installation instructions dynamically
          INSTALL_INSTRUCTIONS="## Installation"
          
          if [ "$WINDOWS_COUNT" -gt "0" ]; then
            INSTALL_INSTRUCTIONS="$INSTALL_INSTRUCTIONS
          - **Windows**: 
            - \`*-win.exe\`: Full installer (recommended)
            - \`*-Portable.exe\`: Portable version (no installation needed)"
          fi
          
          if [ "$APPIMAGE_COUNT" -gt "0" ] || [ "$DEB_COUNT" -gt "0" ] || [ "$RPM_COUNT" -gt "0" ]; then
            INSTALL_INSTRUCTIONS="$INSTALL_INSTRUCTIONS
          - **Linux**:"
            
            if [ "$DEB_COUNT" -gt "0" ]; then
              INSTALL_INSTRUCTIONS="$INSTALL_INSTRUCTIONS
            - Ubuntu/Debian: Install the \`.deb\` package"
            fi
            
            if [ "$RPM_COUNT" -gt "0" ]; then
              INSTALL_INSTRUCTIONS="$INSTALL_INSTRUCTIONS
            - RHEL/Fedora/openSUSE: Install the \`.rpm\` package"
            fi
            
            if [ "$APPIMAGE_COUNT" -gt "0" ]; then
              INSTALL_INSTRUCTIONS="$INSTALL_INSTRUCTIONS
            - Any distro: Use the \`.AppImage\` file (portable)"
            fi
          fi

          if [ "$DMG_COUNT" -gt "0" ] || [ "$MACZIP_COUNT" -gt "0" ]; then
            INSTALL_INSTRUCTIONS="$INSTALL_INSTRUCTIONS
          - **macOS**:"

            if [ "$DMG_COUNT" -gt "0" ]; then
              INSTALL_INSTRUCTIONS="$INSTALL_INSTRUCTIONS
            - Install using the \`.dmg\` disk image"
            fi

            if [ "$MACZIP_COUNT" -gt "0" ]; then
              INSTALL_INSTRUCTIONS="$INSTALL_INSTRUCTIONS
            - Portable: unzip the \`.zip\` archive"
            fi
          fi
          
          # Generate checksums
          echo "## Checksums (SHA256)" > ../checksums.md
          echo "" >> ../checksums.md
          echo '```' >> ../checksums.md
          
          if command -v sha256sum >/dev/null 2>&1; then
            sha256sum * >> ../checksums.md 2>/dev/null || true
          elif command -v shasum >/dev/null 2>&1; then
            shasum -a 256 * >> ../checksums.md 2>/dev/null || true
          fi
          
          echo '```' >> ../checksums.md
          cd ..
          
          # Create release notes
          cat > release_notes.md << EOF
          # VideoSwarm $TAG_NAME
          
          $INSTALL_INSTRUCTIONS
          
          ## What's Changed
          See the commit history for detailed changes in this release.
          
          $(cat checksums.md)
          
          ## Notes
          - Check the README for system requirements and known limitations
          - Report issues on our GitHub repository
          EOF

      - name: Create Release
        env:
          GITHUB_TOKEN: ${{ secrets.GITHUB_TOKEN }}
        run: |
          TAG_NAME="${{ github.ref_name }}"
          
          # Determine if this is a prerelease
          PRERELEASE_FLAG=""
          if [[ "$TAG_NAME" == *"-rc"* ]] || [[ "$TAG_NAME" == *"-beta"* ]] || [[ "$TAG_NAME" == *"-alpha"* ]]; then
            PRERELEASE_FLAG="--prerelease"
          fi
          
          # Create the release
          gh release create "$TAG_NAME" \
            --draft \
            $PRERELEASE_FLAG \
            --title "VideoSwarm $TAG_NAME" \
            --notes-file release_notes.md \
            release-files/*
